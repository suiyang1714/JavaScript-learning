## 引子
> 这一章主要记录关于变量、作用域以及内存问题一些笔记。对于变量和作用域的一些概念或多或少也都明白，所以对于理解基本类型和引用类型的值和执行环境问题也没有多大的问题，对于垃圾回收机制，了解一下就可以。   
> 当然 *ECMAScript* 这三个内容相比其他语言都是比较奇特的。

## 基本类型和引用类型的值

前面也说了 *ECMAScript* 的6种数据类型，并且分为哪两种不同的概念，一个变量包含的数据类型的值也就是这两种：基本类型和引用类型的值。

**基本类型值**指的是简单的数据段，而**引用类型值**指那些可能由多个值构成的对象。

引用类型的值是保存在内存中的对象，**JavaScript** 不允许直接访问内存中的位置，也是就是说，不能直接操作对象的内存空间。  
在操作对象时，当复制保存着对象某个变量时，操作的时对象的引用。但在为对象添加属性的时，操作的是实际的对象。

### 动态属性

给基本类型添加属性，调用时会返回 *undefined*，所以说不能为基本类型添加属性，尽管不会导致任何错误。

### 复制变量值

基本类型的值复制，是给新的变量直接建立一个副本，两个变量的操作不会互相影响。

当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份为新变量分配的空间中。不同的是，这个值得副本实际上是一个指针，而这个指针指向存储在堆中一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

### 传递参数

ECMAScript 中所有函数的参数都是按值传递的，不存在按引用传递和按值传递两种类型。



```
function fn1(obj) {
    obj.name = "Sam";
    obj = new Object ;
    obj.name = "Tom";
}

var person = new Object();
fn1(person);
person.name ; // Sam

```

上述代码首先创建了一个对象，并将其保存在了变量 person 中。然后这个变量被传递到 fn1（） 中之后被复制给了 obj 。在这个函数内部，obj 和 person 引用的是同一个对象。person 指向的对象在堆内存中只有一个，并且是全局对象，但这并不能说明这是按引用来传递的。   
因为后面又重写了 obj ，这个变量引用又变成了一个局部对象。而这个局部对象会在函数执行完毕后立即被销毁。

### 检测类型

前面也提到过，检测基本数据类型的时候用的是 typeof。但是对于 引用类型来说，不管怎么检测都是一个 “object”，所以这时候用到了 instanceof 操作符。  
在检测一个引用类型值和 Object 构造函数时，instanceof 操作符总是返回 true。

## 执行环境及作用域

什么是js的"执行环境"，每当函数被调用的时候，就会产生一个新的执行环境，它是运行中的函数的意思。执行环境中定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之相关联的 **变量对象** ，环境中定义的所有变量和函数都保存在这个对象中。

某个执行环境中所有的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境知道应用程序退出——例如关闭网页或浏览器时才会被销毁）。

当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。   
作用域的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其**活动对象（activation object）** 作为变量对象。活动对象在最开始只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。作用域链中下一个变量对象来自包含(环境)，而再下一个变量对象则来自下一个包含环境。一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

### 小插曲——闭包
这个时候不得不来谈一下 闭包（Closures）。
总的来说我对闭包的理解一直是模棱两可的——它能够使外层环境访问到内层环境的变量的一个函数，也就是说：闭包就是能够读取其他函数内部变量的函数。

对于我心中N个为什么，我都是不清楚的。

**例子1**
```
function fn1(){
　　　　var num = 1;
　　　　function fn2(){
　　　　　　alert(n); 
　　　　}
　　　　return fn2;
　　}
　　var result=fn1();
　　result(); // 1
```

如果说这就是一个闭包的例子，其中fn2就是闭包，我很难理解，Why？

我们都知道Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。

另一方面，在函数外部自然无法读取函数内的局部变量。

所以如果在 fn1 外部直接调用 num 的话，不用说，肯定 “error”。但是 fn2 能够读取到 fn1 中num，如果将 fn2 作为返回值,那么久可以在 fn1 外部读取它的内部变量了。


但是如果仅仅是读取内部变量，何不直接让它返回该变量呢？

**例子2**

```
function fn1(){
　　　　var num = 1;
　　　　return num;
　　}
var result=fn1();
alert(result);
```
这得用闭包另个特性来解释（我不知道这样会不会很牵强）：
* 闭包让这些变量的值始终保持在内存中。

第一段代码中它可以让 fn1 中的变量始终保存在内存中。


```
function fn1(){
　　　　var num = 1;
　　　　numAdd=function(){
　　　　    num+=1;
　　　　}
　　　　function fn2(){
　　　　　　console.log(n); 
　　　　}
　　　　return fn2;
　　}
　　var result = fn1();
　　result(); // 1
　　numAdd();
　　result(); // 2
　　
```
在这段代码中，result实际上就是闭包 fn2 函数。它一共运行了两次，第一次的值是1，第二次的值是2。这证明了，函数 fn1 中的局部变量 num 一直保存在内存中，并没有在 fn1 调用后被自动清除。


然鹅为什么 fn1 的变量会一直保存在内存中呢？原因就在于 fn1 是 fn2 的父函数，而 fn2 被赋给了一个全局变量，这导致 fn2 始终在内存中，而 fn2 的存在依赖于 fn1 ，因此 fn1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

那么再回到之前的问题上，看例子2。如果不使用闭包的话，直接将其赋值给一个全局变量，那么每次调用 fn1 时，都会重新声明 num = 1，造成了 num 的值并不会被保存。


```
function fn1(){
　　　　var num = 1;
　　　　numAdd=function(){
　　　　    num+=1;
　　　　    console.log(num)
　　　　}
　　　　return num;
　　}
　　var result = fn1();
　　result(); // 1
　　numAdd(); // 2
　　result(); // 1
　　numAdd(); // 3
```

numAdd 这个闭包则一直会num保存在内存中,并且发生改变。

### 使用闭包的注意点


1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

### 没有块级作用域

回到主线来。

emmmmm..。  
ES 6 增加了块级作用域。

严格模式下，初始化未经声明的变量会报错。

## 垃圾收集

### 标记清除

JavaScript 中最常用的收集方式是 **标记清除(mark-and-sweep)** 。当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。而当变量离开环境时，则将其标记为“离开环境”。

### 引用计数

引用计数的含义是跟踪记录每一个变量被引用的次数。当声明了一个变量并且将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，该值的引用次数加1 。相反，如果包含对这个值引用的变量又取得了另一个值，，则这个值的引用次数减 1 。当这个值引用次数变成0 时，则说明没有办法在访问这个值了，因为就可以将其占用的内存空间回收回来。

### 管理内存

可以将不再有用的数据设置为 null 来释放其引用——这个做法叫解除引用

## 总结

###  基本类型和引用类型的值

* 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
* 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
* 引用类型的值是对象，保存在堆内存中；
* 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
* 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都是指向同一个对象；

### 参考：

* [instaceof操作符](https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/)
* [学习JavaScript闭包(Closures)](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
* [MDN——Closures](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
* [浅谈js中的执行环境和执行环境对象](http://www.cnblogs.com/jtxn/p/5426469.html)